use crate::commands::basic::*;
use crate::commands::aob_injection::*;
use crate::commands::mem_alloc::*;
use crate::commands::lobby_members::*;
use crate::utils::memory::{enum_memory_regions, MemoryRegion};
use std::error::Error;
use std::sync::Mutex;
use windows::Win32::System::Memory::{PAGE_EXECUTE, PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE};

pub struct GameMainLoopOptions {
    view_lobby_memebers: bool
}

pub struct GameMainLoop {
    pid: u32,
    address: usize,
    options: GameMainLoopOptions,
    lock: Mutex<bool>,
    mem_alloc: MemoryAllocator,
    aob_injection: AobInjection,
    code: String,

    /// Features
    lobby_members: LobbyMembers,
}

impl GameMainLoop {
    pub fn new(pid: u32, options: GameMainLoopOptions) -> Result<Self, Box<dyn Error>> {
        let address = Self::main_loop_init(pid)?;
        let mem_alloc = MemoryAllocator::new(pid, 0x1000)?;
        /*
        push rcx
        mov rcx, qword ptr [var_ptr_lobby]
        mov rax,  
        */
        let code = format!("mov rax, {}", mem_alloc.var_ptr_lobby.address);
        let aob_injection = AobInjection::new(pid, address, "mov rsi, qword ptr [{}], 1")?;
        let lobby_members = LobbyMembers::new(pid, address)?;
        Ok(Self { pid, address, options, lobby_members })
    }

    pub fn main_loop_init(pid: u32) -> Result<usize, Box<dyn Error>> {
        let hex_pattern = "55 48 8B ?? 48 83 ?? ?? 48 B8 ?? ?? ?? ?? ?? ?? ?? ?? 48 89 ?? ?? 48 8B ?? 48 83 ?? ?? E8 ?? ?? ?? ?? 48 89 ?? ?? ?? 48 83 ?? ?? 88 ?? ?? 48 83 ?? ?? E8 ?? ?? ?? ?? 48 89 ?? ?? ?? 48 83 ?? ?? 48 B9 ?? ?? ?? ?? ?? ?? ?? ?? 48 8B ?? 48 89 ?? ?? 4C ?? ?? ?? 4C ?? ?? ?? 4D ?? ?? 0F ?? ?? ?? ?? ?? 49 ?? ?? ?? ?? ?? ?? ?? ?? ?? 4D ?? ?? 4C ?? ?? ?? 4D ?? ?? ?? 4C ?? ?? ?? 4D ?? ?? 75 ?? 48 B8 ?? ?? ?? ?? ?? ?? ?? ?? 48 83 ?? ?? FF ?? 48 89 ?? ?? ?? 41 ?? ?? ?? 85 ?? 75 ?? 48 83 ?? ?? 41 ?? ?? ?? 48 89 ?? ?? ?? 48 83 ?? ?? EB ?? 49 ?? ?? ?? 48 83 ?? ?? 41 ?? ?? ?? 48 89 ?? ?? ?? 48 83 ?? ?? 48 B9 ?? ?? ?? ?? ?? ?? ?? ?? 48 8B ?? 48 89 ?? ?? 4C ?? ?? ?? 4C ?? ?? ?? 4D ?? ?? 0F ?? ?? ?? ?? ?? 4D ?? ?? 75 ?? 48 83 ?? ?? 68 ?? ?? ?? ?? 48 B8 ?? ?? ?? ?? ?? ?? ?? ?? 48 83 ?? ?? FF ?? 48 89 ?? ?? ?? 4D ?? ?? 45 ?? ?? ?? ?? ?? ?? 44 ?? ?? ?? 4D ?? ?? 0F ?? ?? ?? ?? ?? 4D ?? ?? ?? 4C ?? ?? ?? 4D ?? ?? 75 ?? 48 B8 ?? ?? ?? ?? ?? ?? ?? ?? 48 83 ?? ?? FF ?? 48 89 ?? ?? ?? 4D ?? ?? 4D ?? ?? ?? 49 ?? ?? 48 83 ?? ?? 41 ?? ?? ?? ?? ?? ?? 48 89 ?? ?? ?? 48 83 ?? ?? 48 8B ?? ?? 48 83 ?? ?? 5D 48 C3";

        let hex_pattern_

        let executable_protection = PAGE_EXECUTE.0 | PAGE_EXECUTE_READ.0 | PAGE_EXECUTE_READWRITE.0;
        let addrs = aob_scan_mrprotect(pid, hex_pattern, executable_protection)?;

        if addrs.is_empty() {
            tracing::error!("Pattern not found");
            return Err("Pattern not found".into());
        }

        //LobbyMembers

        Ok(addrs[0])
    }

    pub fn update_options(&mut self, options: GameMainLoopOptions) {
        self.options = options;
    }

    /// Apply or remove auto-accept at the specified address
// pub fn auto_accept_apply(pid: u32, address: usize, enable: bool) -> Result<bool, Box<dyn Error>> {
//     let mut injection = INJECTION.lock().unwrap();
    
//     if enable {
//         if injection.is_none() {
//             *injection = Some(AobInjection::new(pid, address, "mov dl, 1")?);
//             tracing::info!("Successfully injected auto-accept code");
//         }
//     } else if let Some(inj) = injection.as_ref() {
//         inj.undo()?;
//         *injection = None;
//         tracing::info!("Successfully removed auto-accept code");
//     }
    
//     Ok(enable)
// }

    pub fn apply(&mut self) -> Result<(), Box<dyn Error>> {
        Ok(())
    }
}